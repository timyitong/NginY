/**	Notice:
	The InvertedList is stored as an int [],
		in format as follows:
			int[0]=term_frequence;
			int[1]=term_total_count;
			int[2]=doc_frequence;
			int[3..n]={doc_id,term_freq,doc_length,term_loc1,term_loc2,.....}
					...
			int[n..n]={doc_id,term_freq,doc_length,term_loc1,term_loc2,.....}
	This class is its hashmap and operater class.
*/
package com.nginy.list;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import java.util.StringTokenizer;
import java.util.HashMap;
import java.util.LinkedList;
import java.io.InputStreamReader;
import com.nginy.list.ScoreList;
import com.nginy.parser.Tree;
import com.nginy.list.StopList;


public class InvertedList{
	public int doc_count;
	int term_count;  //total_term_count
	int term_freq;   //collection_term_frequence
	String term;
	String stemmed_term;
	private static HashMap <String,int[]> hashmap=null;
	public int [] list=null;
	private static int[] readFile(File file){     // this is the new version of readFile function
		int freq=0;
		int count=0;
		int [] invlist=null;
		StringTokenizer st=null;
		try {
		BufferedReader br=new BufferedReader(new FileReader(file));
		String line=br.readLine();
		st=new StringTokenizer(line);
		st.nextToken();			//term
		st.nextToken();			//stemmed_term
		freq=Integer.parseInt(st.nextToken());	//term_fequence
		count=Integer.parseInt(st.nextToken());	//term_count
		int length=Integer.parseInt(st.nextToken());  //doc_frequency

		invlist=new int[freq+length*3+3];
		invlist[0]=freq;	//term_frequence
		invlist[1]=count;	//term_count
		invlist[2]=length;	//doc_frequence

		int i=3;			//start from the 4th one, put in the record [DOC_ID TF DOC_LEN Loc1 loc2 loc3.....]

			while((line=br.readLine())!=null){
				st=new StringTokenizer(line);
				while(st.hasMoreTokens()){
					invlist[i]=Integer.parseInt(st.nextToken());
					i++;
				}
			}
		br.close();
		}catch(Exception e){
					System.out.println(file.getName());
			e.printStackTrace();}
		return invlist;
	}
	public InvertedList(String url){

		try {
		BufferedReader br=new BufferedReader(new FileReader(new File(url)));
		String line=br.readLine();
		StringTokenizer st=new StringTokenizer(line);
		term=st.nextToken();
		stemmed_term=st.nextToken();
		term_freq=Integer.parseInt(st.nextToken());
		term_count=Integer.parseInt(st.nextToken());
		int length=0;
		while((line=br.readLine())!=null){
			length++;
		}

		this.doc_count=length;
		list=new int[term_freq+length*3];

		int i=0;
		
		br=new BufferedReader(new FileReader(new File(url)));
		br.readLine();
			while((line=br.readLine())!=null){
				st=new StringTokenizer(line);
				while(st.hasMoreTokens()){
					list[i]=Integer.parseInt(st.nextToken());
					i++;
				}
			}
		}catch(Exception e){e.printStackTrace();}


	}
	public static void readIntoMemory(int num,String folder){
		if (hashmap==null)
			hashmap=new HashMap <String,int[]> (num); 
		// declare the possible space first could reduce the rehash time a little bit
		File file=new File("data/"+folder+"/");
		File [] files=file.listFiles();

		for (int i=0;i<Math.min(files.length,num);i++){
			String fullname=files[i].getName();
			//here we ignore the [StopWord].inv and the .DS_Store generated by OS X
			if (!fullname.equals(".DS_Store") && ! StopList.hasStopWord(fullname.substring(0,fullname.indexOf('.'))))
				hashmap.put(fullname,InvertedList.readFile(files[i]));
		}

	}
	public static int[] getInvList(String key){
		if (key.indexOf('.')==-1)
			key=key+".inv";
		int [] list=hashmap.get(key);
		if (list==null)
			list=InvertedList.readFile(new File("data/inv_local/"+key));
		return list;
	}

}