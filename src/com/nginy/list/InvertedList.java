/**	Notice:
	The InvertedList is stored as an int [],
		in format as follows:
			int[0]=term_frequence;
			int[1]=term_total_count;
			int[2]=doc_frequence;
			int[3..n]={doc_id,term_freq,doc_length,term_loc1,term_loc2,.....}
					...
			int[n..n]={doc_id,term_freq,doc_length,term_loc1,term_loc2,.....}
	This class is its hashmap and operater class.
*/
package com.nginy.list;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.File;
import java.util.StringTokenizer;
import java.util.HashMap;
import java.util.LinkedList;
import java.io.InputStreamReader;
import com.nginy.list.ScoreList;
import com.nginy.parser.Tree;
import com.nginy.list.StopList;


public class InvertedList{
	public int doc_count;
	int term_count;  //total_term_count
	int term_freq;   //collection_term_frequence
	String term;
	String stemmed_term;
	private static HashMap <String,int[]> hashmap=null;
	public int [] list=null;
	private static int [] readFile(File file){
		int freq=0;
		int count=0;
		int [] invlist=null;
		StringTokenizer st=null;
		try {
		BufferedReader br=new BufferedReader(new FileReader(file));
		String line=br.readLine();
		st=new StringTokenizer(line);
		st.nextToken();			//term
		st.nextToken();			//stemmed_term
		freq=Integer.parseInt(st.nextToken());	//term_fequence
		count=Integer.parseInt(st.nextToken());	//term_count

		int length=0;
		while((line=br.readLine())!=null){
			length++;
		}
		
		invlist=new int[freq+length*3+3];
		invlist[0]=freq;	//term_frequence
		invlist[1]=count;	//term_count
		invlist[2]=length;	//doc_frequence

		int i=3;			//start from the 4th one, put in the record [DOC_ID TF DOC_LEN Loc1 loc2 loc3.....]
		br=new BufferedReader(new FileReader(file));
		br.readLine();
			while((line=br.readLine())!=null){
				st=new StringTokenizer(line);
				while(st.hasMoreTokens()){
					invlist[i]=Integer.parseInt(st.nextToken());
					i++;
				}
			}
		br.close();
		}catch(Exception e){
					System.out.println(file.getName());
			e.printStackTrace();}
		return invlist;
	}
	public InvertedList(String url){

		try {
		BufferedReader br=new BufferedReader(new FileReader(new File(url)));
		String line=br.readLine();
		StringTokenizer st=new StringTokenizer(line);
		term=st.nextToken();
		stemmed_term=st.nextToken();
		term_freq=Integer.parseInt(st.nextToken());
		term_count=Integer.parseInt(st.nextToken());
		int length=0;
		while((line=br.readLine())!=null){
			length++;
		}

		this.doc_count=length;
		list=new int[term_freq+length*3];

		int i=0;
		
		br=new BufferedReader(new FileReader(new File(url)));
		br.readLine();
			while((line=br.readLine())!=null){
				st=new StringTokenizer(line);
				while(st.hasMoreTokens()){
					list[i]=Integer.parseInt(st.nextToken());
					i++;
				}
			}
		}catch(Exception e){e.printStackTrace();}


	}
	public static void readIntoMemory(int num,String folder){
		if (hashmap==null)
			hashmap=new HashMap <String,int[]> (num); 
		// declare the possible space first could reduce the rehash time a little bit
		File file=new File("data/"+folder+"/");
		File [] files=file.listFiles();

		for (int i=0;i<files.length;i++){
			String fullname=files[i].getName();
			//here we ignore the [StopWord].inv and the .DS_Store generated by OS X
			if (!fullname.equals(".DS_Store") && ! StopList.hasStopWord(fullname.substring(0,fullname.indexOf('.'))))
				hashmap.put(fullname,InvertedList.readFile(files[i]));
		}

	}
	public static int[] getInvList(String key){
		int [] list=hashmap.get(key);
		if (list==null)
			list=hashmap.get(key.substring(0,key.indexOf('.'))+".inv");
		return list;
	}
	public static int[] NEAR(int[] list1,int[] list2, int width){
		int [] result;
		if (list1.length>list2.length)
			result=new int [list1.length];
		else
			result=new int[list2.length];

		int term_freq=0;	//term_freq
		int term_count=0;	//here we don't know the combined list's complete result, so this one is always 0
		int doc_length=0;	//Doc length
		int i=3,j=3;
		int term_i=0,term_j=0;
		int i_length=0,j_length=0;
		boolean matching=false;
		int result_point=3;
		int match_freq_point=0; //the index of the int[] which counts how many pairs has been matched
		while(	i<list1.length && j<list2.length ){
			if (matching){		//if the DOCID matched
				int cur_w=list1[i]-list2[j];
				if (cur_w>0){	//not match, list2 fall behind
					j++;
					j_length--;
				}else if (cur_w< (0-width) ){	//not match, list1 fall behind
					i++;
					i_length--;
				}else{		//  -width <= cur_w < 0
							//match
							//ATTENTION list1 should always in front
					// check if DOCID has been written yet
					if (match_freq_point==0){
						result[result_point]=list1[term_i];  //DOC_ID
						match_freq_point=result_point+1;		// match_freq_point calculate
						result[match_freq_point]=0;
						result[result_point+2]=list1[term_i+2]; //DOC_Length

						result_point=result_point+3;

						doc_length++;  //ADD Total doc freq
					}
					result[result_point]=list2[j];
					result[match_freq_point]++;	//if match , then add match frequence count
					term_freq++;	//ADD Total term freq

					result_point++;
					i++;
					j++;
					i_length--;
					j_length--;
				}
		
				if (i_length==0 || j_length==0){ //if one of the locs has reached the end
					i=i+i_length;
					j=j+j_length;
		
		
					term_i=0;
					term_j=0;
					i_length=0;
					j_length=0;
					match_freq_point=0;
					matching=false;
				}
			}else{	//if DOCID not matched
				if (list1[i]==list2[j]){
					matching=true;
					i_length=list1[i+1];
					j_length=list2[j+1];
					term_i=i;
					term_j=j;
					i+=3;
					j+=3;
				}
				else if (list1[i]>list2[j])
					j=j+list2[j+1]+3;
				else 
					i=i+list1[i+1]+3;
			}
		}
		result[0]=term_freq;
		result[1]=term_count;
		result[2]=doc_length;

		int [] new_result=new int[result_point]; //shorten the length of int []
		for(int k=0;k<new_result.length;k++)
			new_result[k]=result[k];

		return new_result;
	}
	public static ScoreList NEAR(LinkedList <Tree> query_list,int width){
		String [] words=new String [query_list.size()];
		//check if the syntax if right:
		Tree t=null;
		int i=0;
		while((t=query_list.pollFirst())!=null){
			if (!t.tree_type.equals("COM"))
				return null;		
			else{
				words[i]=t.keyword;
				i++;
			}
						
		}
		
		//read all invertedlists:
		int [] inv_list_result=null;
		int [] inv_list_new=null;
		for (i=0;i<words.length;i++){
			inv_list_new=InvertedList.getInvList(words[i]+".inv");
			if (inv_list_result==null){
				inv_list_result=inv_list_new;
			}else{
				inv_list_result=InvertedList.NEAR(inv_list_result,inv_list_new,width);
			}
		}
		return new ScoreList(inv_list_result,"inv");

	}
}